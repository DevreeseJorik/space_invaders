/* autogenerated by Processing revision 1276 on 2022-01-03 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import processing.sound.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class space_invaders extends PApplet {



SoundFile bgMusic;
SoundFile laserShot;
SoundFile laserHit;

JSONObject gamedata;

int score = 0;

int invaderIds = 11;
int invaderRows = 7;

int damageTypes = 3;
int damageSprites = 2;
int cFrame = 0;
int animFrame = 0;
int animFrameCount = 60;

int horInterval = 10;
int spriteMoveCount = 1;
int invaderXOffs = -(horInterval*spriteMoveCount);
int moveFrame = 0;
int moveFrameCount = 60;

Difficulty[] difficulties = new Difficulty[0];

SpaceInvader[][] invaders;
PImage invaderSpriteSheet;
int invSpriteWidth;
int invSpriteHeight;
Bullet[] invaderBullets = new Bullet[0];

Player player = new Player();
PImage playerSprite;
int playerSpriteWidth;
int playerSpriteHeight;

Bullet[] playerBullets = new Bullet[0];
int[][] angles = {{0},{-10,10},{-10,0,10},{-20,-10,0,10,20},{-30,-20,10,30}};

//int debugCount = 0;

//--------------------------------------------------------------------------//

 public void setup() {
  /* size commented out by preprocessor */;
  frameRate(60);
  background(0xFF100020);
  
  invaderSpriteSheet = loadImage("sprites_invaders.png");
  invSpriteWidth = invaderSpriteSheet.width/invaderRows;
  invSpriteHeight = invaderSpriteSheet.height/invaderIds;
  
  //bgMusic = new SoundFile(this,"bgMusic_1.mp3");
  //bgMusic.loop();
  
  laserShot = new SoundFile(this,"laserShot.mp3");
  laserHit = new SoundFile(this,"laserHit.mp3");

  gamedata = loadJSONObject("gamedata.json");
  println(gamedata.getInt("id"));
  
  playerSprite = loadImage("spaceship.png");
  playerSprite.resize(0,60);
 
  createLevels();
  //createLevel(0);
  
  textSize(24);
  textAlign(LEFT);
}

 public void draw() {
  cFrame ++;
  animFrame = (cFrame%(animFrameCount*damageSprites))/animFrameCount;
  addXOffsetInvaders();

  background(0xFF100020);
  updatePlayer();
  drawPlayer();

  updateInvaders();
  
  updatePlayerBullets();
  drawPlayerBullets();
  
  showGui();
}

 public void showGui() {
  fill(0xFFD0FF3D);
  text("Score " + score,50,50);

}

 public void createLevels() {
  createDifficulties();
  
  int rowCount = 19;
  int colCount = 4;
  createLevel(rowCount,colCount,0);
  
}

 public void createLevel(int rows, int cols,int type) {
  if (type == 0) {
      invaders  = new SpaceInvader[cols][rows];
      for (int y = 0; y < cols; y++) {
        for (int x = 0; x < rows; x++) {
           int horPadding = (width - (invSpriteWidth*invaders[y].length))/2;
          SpaceInvader invader = new SpaceInvader();
          invader.damage = 10;
          invader.spriteId = 0; //x%invaderIds;
          invader.clr = 0xFFD0FF3D;
          invader.shootingSpeed = 5;
          invader.maxHealth = 50;
          invader.health = invader.maxHealth;
          int[] pos = {horPadding + invSpriteWidth*x,60+invSpriteHeight*y};
          invader.initialPos = pos;
          arrayCopy(invader.initialPos,invader.pos);
          invaders[y][x] = invader;
        }
      }
  addPlayer(0);
  }  
}

 public void addPlayer(int type) {
  if (type == 0) {
    player.maxHealth = 200;
    player.health = player.maxHealth;
    player.damage = 10;
    player.shootingSpeed = 20;
    int[] pos = {width/2 - playerSprite.width/2,height-100};
    player.pos = pos;
    player.speed = 5;
    player.baseShootingCooldown = 40;
  }

}

 public void createDifficulties() {
  Difficulty easy = new Difficulty();
  easy.durationMultiplier = 5;
  difficulties = (Difficulty[]) append(difficulties,easy);
  
}

 public void addXOffsetInvaders () {
  moveFrame = cFrame%(moveFrameCount+1)/moveFrameCount; //becomes 1 once every moveFrameCount's, otherwise 0
  
  invaderXOffs = invaderXOffs + horInterval*moveFrame;

  if (invaderXOffs == horInterval*spriteMoveCount) {
    horInterval = -horInterval;
  }
  
  for (int y = 0; y < invaders.length; y++) {
    for (int x = 0; x < invaders[y].length; x++) {
      int[] pos = new int[2];
      arrayCopy(invaders[y][x].initialPos,pos); // otherwise you'll get both arrays using the same array
      pos[0] += invaderXOffs;
      
      invaders[y][x].pos = pos;
    }
  } 
}

 public void updateInvaders() {
  for (int y = 0; y < invaders.length; y++) {
    for (int x = 0; x < invaders[y].length; x++) {
      updateInvader(invaders[y][x]);
      if (invaders[y][x].shootingCooldown != 0) {
         invaders[y][x].shootingCooldown--;
      }
    }
  }
  drawInvaderBullets();
  updateInvaderBullets();
}

 public void updateInvader(SpaceInvader obj) {
  float percentageHealth = (obj.health/obj.maxHealth);
  PImage sprite = getSpriteInvader(obj,percentageHealth);
  if (sprite != null) {
    image(sprite,obj.pos[0],obj.pos[1]); 
    if (obj.health > 0) {
    drawHealthBar(obj,percentageHealth);
    }
  }
  addBulletInvader(obj);
}

 public PImage getSpriteInvader(SpaceInvader obj,float percentageHealth)
{
  int xOffset = PApplet.parseInt((damageTypes)-(percentageHealth*damageTypes));
  int yOffset = obj.spriteId;
  //println(xOffset);
  
  if (percentageHealth == 0) {
    if (!obj.isDead) {
      if (obj.framesUntilRemoval != 0) {
        PImage sprite = invaderSpriteSheet.get(xOffset*2* invSpriteWidth,yOffset * invSpriteHeight,invSpriteWidth,invSpriteHeight);
        obj.framesUntilRemoval --;
        return sprite;
      }
      dropItem(obj);
      score += obj.scoreWorth;
      obj.isDead = true;
    }
    return null;
  }
  
  PImage sprite = invaderSpriteSheet.get((xOffset*2+animFrame)* invSpriteWidth,yOffset * invSpriteHeight,invSpriteWidth,invSpriteHeight);
  return sprite;
}

 public void drawHealthBar(SpaceInvader obj, float percentageHealth) {
  int horPadding = 20;
  int vertPadding = 8;
  int hBarHeight = 4;
  fill(setOpacity(obj.clr,70));
  rect(obj.pos[0]+horPadding,obj.pos[1] + vertPadding,invSpriteWidth-horPadding*2,hBarHeight); // max health bar with reduced opacity 
  fill(obj.clr);
  rect(obj.pos[0]+horPadding,obj.pos[1] + vertPadding,(invSpriteWidth-horPadding*2)*percentageHealth,hBarHeight); // current health bar
}


 public void addBulletInvader(SpaceInvader obj) {
  int randomValue = PApplet.parseInt(random(1,2000));
  if (randomValue <= 1 & obj.shootingCooldown == 0 & obj.health !=0) {
    obj.shootingCooldown = obj.baseShootingCooldown;

    Bullet bullet = new Bullet();
    bullet.isInvader = true ;
    arrayCopy(obj.pos,bullet.pos);
    bullet.pos[0] += invSpriteWidth/2- bullet.width/2;
    bullet.clr = obj.clr;
    bullet.damage = obj.damage;
    bullet.angle = 0;
    bullet.speed = obj.shootingSpeed;
    
    invaderBullets = (Bullet[]) append(invaderBullets,bullet);
  }
}

 public void drawInvaderBullets() {
  for (int i = 0; i < invaderBullets.length;i++) {
    fill(invaderBullets[i].clr);
    rect(invaderBullets[i].pos[0],invaderBullets[i].pos[1],invaderBullets[i].width,invaderBullets[i].height);

  }
  
}

 public void updateInvaderBullets() {
  Bullet[] tempBullets = new Bullet[0];
  
  for (int i = 0; i < invaderBullets.length;i++) {
    
    //invaderBullets[i].pos[0] += invaderBullets[i].angle;
    invaderBullets[i].pos[1] += 3;//invaderBullets[i].speed;

    if (invaderBullets[i].pos[1] < height) {
       if (!detectPlayerHit(invaderBullets[i])) {
        tempBullets = (Bullet[]) append(tempBullets,invaderBullets[i]);
       }
    }
  }
  
  invaderBullets = tempBullets;
}

 public void dropItem(SpaceInvader obj) {
  int randomValue = PApplet.parseInt(random(1,101));
  if (randomValue <= obj.dropChance) {
    Upgrade upgrade = new Upgrade();
    upgrade.upgradeId = PApplet.parseInt(random(0,5));
    
  }
}


 public void updatePlayer() {
  if (player.keyheld[2] == true) {
    if (player.shootingCooldown == 0) {
      addPlayerBullets(player.bulletCount-1);
    }
  }
  
  if (player.keyheld[0] == true) {
    player.pos[0] -= player.speed;
    if (player.pos[0] < 10) {
      player.pos[0] = 10;
    }
    return;
  }
  
  if (player.keyheld[1] == true) {
    player.pos[0] += player.speed;
    if (player.pos[0] > (width - playerSprite.width - 10)) {
      player.pos[0] = width - playerSprite.width - 10;
    }
    return;
  }
  
}

 public void drawPlayer() {
  image(playerSprite,player.pos[0],player.pos[1]);
  int horPadding = -10;
  int vertPadding = 4+playerSprite.height;
  int hBarHeight = 5;
  int healthColor = getHealthColor(player.health,player.maxHealth);

  fill(setOpacity(healthColor,70));
  rect(player.pos[0]+horPadding,player.pos[1] + vertPadding,playerSprite.width-horPadding*2,hBarHeight); // max health bar with reduced opacity 
  fill(healthColor);
  rect(player.pos[0]+horPadding,player.pos[1] + vertPadding,(playerSprite.width-horPadding*2)*(player.health/player.maxHealth),hBarHeight); // current health bar
}


 public int getHealthColor(float health, float maxhealth ){
  float percentageHealth = health/maxhealth;
  int baseColor = 0xFFD0FF3D;
  int[] hue =  {PApplet.parseInt((1-percentageHealth+0.1f)*255),-PApplet.parseInt(pow((1-percentageHealth)*5,2)*10),-PApplet.parseInt((1-percentageHealth)*100)};
  //println(-int(pow(1-percentageHealth*20,2)));
  return addHue(baseColor, hue);
}

 public void drawPlayerBullets() {
  for (int i = 0; i < playerBullets.length;i++) {
    rect(playerBullets[i].pos[0],playerBullets[i].pos[1],playerBullets[i].width,playerBullets[i].height);
  }
}

 public void addPlayerBullets(int count) {
  for (int i = 0; i < count; i++ ) {
    player.shootingCooldown = player.baseShootingCooldown;
    Bullet bullet = new Bullet();
    bullet.isInvader = false;
    arrayCopy(player.pos,bullet.pos);
    bullet.pos[0] += playerSprite.width/2 - bullet.width/2;
    bullet.damage = player.damage;
    bullet.angle = angles[count-1][i];
    
    playerBullets = (Bullet[]) append(playerBullets,bullet);
    if (laserShot.isPlaying()) {laserShot.stop();}
    laserShot.play();
  }
  
}

 public void updatePlayerBullets() {

  Bullet[] tempBullets = new Bullet[0];
  for (int i = 0; i < playerBullets.length;i++) {
    
    playerBullets[i].pos[0] += playerBullets[i].angle;
    playerBullets[i].pos[1] -= player.shootingSpeed;

    if (playerBullets[i].pos[1] > 0) {
      if (!detectInvaderHit(playerBullets[i])) {
        tempBullets = (Bullet[]) append(tempBullets,playerBullets[i]);
      }
    }
  }
  playerBullets = tempBullets;
  
  player.shootingCooldown --;
  if (player.shootingCooldown < 0) {
    player.shootingCooldown = 0;
  }
}

 public boolean detectInvaderHit(Bullet bullet) {
  for (int y = 0; y < invaders.length; y++) {
    for (int x = 0; x < invaders[y].length; x++) {
      int[] pos = invaders[y][x].pos;
      if ((bullet.pos[0]+bullet.width/2 >= pos[0]+10) & (bullet.pos[0]+bullet.width/2  <= pos[0]+invSpriteWidth-10)){
        if ((bullet.pos[1]+bullet.height/2 >= pos[1]+10) & (bullet.pos[1]+bullet.height/2  <= pos[1]+invSpriteHeight-10)){
          if (invaders[y][x].health != 0) {
            invaders[y][x].health -= bullet.damage;
            if (invaders[y][x].health < 0) {
              invaders[y][x].health = 0;
            }
            if (laserHit.isPlaying()) {laserHit.stop();}
            laserHit.play();
            return true;
          }
        }
      }      
    }
  }
  
  return false;
}

 public boolean detectPlayerHit(Bullet bullet) {
  int[] pos = player.pos;
  
  if ((bullet.pos[0] >= pos[0]-bullet.width) & (bullet.pos[0]+bullet.width  <= pos[0]+playerSprite.width)){
    if ((bullet.pos[1]+bullet.height/2 >= pos[1]+20) & (bullet.pos[1]+bullet.height/2  <= pos[1]+playerSprite.height)){
      if (player.health != 0) {
        player.health -= bullet.damage;
        if (player.health < 0) {
          player.health = 0;
        }
        if (laserHit.isPlaying()) {laserHit.stop();}
        laserHit.play();
        return true;
      }
    }
  }
  
  return false;
}


 public int setOpacity(int  clr,int opacity) {
  int r = (clr >> 16) & 0xFF;
  int g = (clr >> 8) & 0xFF;
  int b = clr & 0xFF;
  return color(r,g,b,opacity);
}

 public int addHue(int  clr,int[] hue){
  int r = (clr >> 16) & 0xFF;
  int g = (clr >> 8) & 0xFF;
  int b = clr & 0xFF;
  return color(r+hue[0],g+hue[1],b+hue[2]);
}


 public void keyPressed(){
  if (keyCode == LEFT) {
    player.keyheld[0] = true;
  }
  
    if (keyCode == RIGHT) {
    player.keyheld[1] = true;
  }

  if (key == ' ') {
    player.keyheld[2] = true;
  }
}

 public void keyReleased() {
  if (keyCode == LEFT) {
    player.keyheld[0] = false;
  }
  if (keyCode == RIGHT) {
     player.keyheld[1] = false;
  }
  
  if (key == ' ') {
    player.keyheld[2] = false;
  }
  
}

class Player {
  int spriteId;
  //int[] initialPos = new int[2];
  int[] pos = new int[2];
  boolean[] keyheld  = {false,false,false};
  int damage;
  float health;
  float maxHealth;
  int shootingSpeed;
  int shootingCooldown = 0;
  int baseShootingCooldown;
  int speed;
  int bulletCount = 2;
  
}

class SpaceInvader{
  int spriteId;
  int[] initialPos = new int[2];
  int[] pos = new int[2];
  int scoreWorth = 100;
  int clr;
  float health;
  float maxHealth;
  int damage;
  int shootingSpeed;
  int shootingCooldown = 0;
  int baseShootingCooldown = 100;
  int framesUntilRemoval = 20; // remove sprite after several frames of death animation
  int dropChance = 10;
  boolean isDead = false; 
  
}

class Bullet {
  boolean isInvader; // player or invader?
  int effectID;
  int damage;
  int speed;
  int[] pos = new int[2];
  int width = 10;
  int height = 10;
  int angle;
  int clr;
}


class Difficulty {
  int durationMultiplier;
  int damageMultiplier;
  int shootingSpeedMultiplier;
  int shootingChance;
  int dropChance;
}

class Level {
  int baseDuration;
  SpaceInvader[][] enemyMatrix; //derive rows and cols from this
}

class Upgrade {
  int time;
  int upgradeId;
  float damageMultiplier;
  int extraShots;
  int cooldownMultiplier;
  int speedMultiplier;
  int[] pos = new int[2];
  int scoreMultiplier;
}


  public void settings() { size(1600, 1000); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "space_invaders" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
